// Generated by CoffeeScript 1.4.0
var ASTWalker, Syntax;

Syntax = {
  AssignmentExpression: 'AssignmentExpression',
  ArrayExpression: 'ArrayExpression',
  BlockStatement: 'BlockStatement',
  BinaryExpression: 'BinaryExpression',
  BreakStatement: 'BreakStatement',
  CallExpression: 'CallExpression',
  CatchClause: 'CatchClause',
  ConditionalExpression: 'ConditionalExpression',
  ContinueStatement: 'ContinueStatement',
  DoWhileStatement: 'DoWhileStatement',
  DebuggerStatement: 'DebuggerStatement',
  EmptyStatement: 'EmptyStatement',
  ExpressionStatement: 'ExpressionStatement',
  ForStatement: 'ForStatement',
  ForInStatement: 'ForInStatement',
  FunctionDeclaration: 'FunctionDeclaration',
  FunctionExpression: 'FunctionExpression',
  Identifier: 'Identifier',
  IfStatement: 'IfStatement',
  Literal: 'Literal',
  LabeledStatement: 'LabeledStatement',
  LogicalExpression: 'LogicalExpression',
  MemberExpression: 'MemberExpression',
  NewExpression: 'NewExpression',
  ObjectExpression: 'ObjectExpression',
  Program: 'Program',
  Property: 'Property',
  ReturnStatement: 'ReturnStatement',
  SequenceExpression: 'SequenceExpression',
  SwitchStatement: 'SwitchStatement',
  SwitchCase: 'SwitchCase',
  ThisExpression: 'ThisExpression',
  ThrowStatement: 'ThrowStatement',
  TryStatement: 'TryStatement',
  UnaryExpression: 'UnaryExpression',
  UpdateExpression: 'UpdateExpression',
  VariableDeclaration: 'VariableDeclaration',
  VariableDeclarator: 'VariableDeclarator',
  WhileStatement: 'WhileStatement',
  WithStatement: 'WithStatement'
};

ASTWalker = (function() {

  function ASTWalker(options) {
    if (options == null) {
      options = {};
    }
    if (options.walk != null) {
      this.on_walk = options.walk;
    }
    this._stack = [];
    this._path = [];
  }

  ASTWalker.prototype.walk = function(node, path) {
    if (path == null) {
      path = false;
    }
    if (!node) {
      return node;
    }
    this._stack.push(node);
    if (path) {
      this._path.push(path);
    }
    if (typeof this.on_walk === 'function') {
      node = this.on_walk.call(this, node);
    }
    node = this[node.type](node);
    if (path) {
      this._path.pop();
    }
    this._stack.pop();
    if (this._stack.length === 0) {
      node = this.on_walkComplete(node);
    }
    return node;
  };

  ASTWalker.prototype.on_walkComplete = function(node) {
    return node;
  };

  ASTWalker.prototype.path = function() {
    return this._path.join('->');
  };

  ASTWalker.prototype.parent = function() {
    return this._stack[this._stack.length - 2] || null;
  };

  ASTWalker.prototype.depth = function() {
    return this._stack.length;
  };

  ASTWalker.prototype.get = function(node, path) {
    var p, _i, _len;
    if (typeof path === 'string') {
      path = path.split('->');
    }
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      p = path[_i];
      if (/(\S+)\[(\d+)\]/.test(p)) {
        node = node[RegExp.$1][parseInt(RegExp.$2, 10)];
      } else {
        node = node[p];
      }
    }
    return node;
  };

  ASTWalker.prototype.AssignmentExpression = function(node) {
    node.left = this.walk(node.left, "left");
    node.right = this.walk(node.right, "right");
    return node;
  };

  ASTWalker.prototype.ArrayExpression = function(node) {
    var el, i, _i, _len, _ref;
    _ref = node.elements;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.elements[i] = this.walk(el, "elements[" + i + "]");
    }
    return node;
  };

  ASTWalker.prototype.BlockStatement = function(node) {
    var el, i, _i, _len, _ref;
    _ref = node.body;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.body[i] = this.walk(el, "body[" + i + "]");
    }
    return node;
  };

  ASTWalker.prototype.BinaryExpression = function(node) {
    this.walk(node.left, "left");
    this.walk(node.right, "right");
    return node;
  };

  ASTWalker.prototype.BreakStatement = function(node) {
    node.label = this.walk(node.label, "label");
    return node;
  };

  ASTWalker.prototype.CallExpression = function(node) {
    var el, i, _i, _len, _ref;
    node.callee = this.walk(node.callee, "callee");
    _ref = node["arguments"];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node["arguments"][i] = this.walk(el, "arguments[" + i + "]");
    }
    return node;
  };

  ASTWalker.prototype.CatchClause = function(node) {
    node.param = this.walk(node.param, "param");
    node.body = this.walk(node.body, "body");
    return node;
  };

  ASTWalker.prototype.ConditionalExpression = function(node) {
    node.test = this.walk(node.test, "test");
    node.alternate = this.walk(node.alternate, "alternate");
    node.consequent = this.walk(node.consequent, "consequent");
    return node;
  };

  ASTWalker.prototype.ContinueStatement = function(node) {
    node.label = this.walk(node.label, "label");
    return node;
  };

  ASTWalker.prototype.DoWhileStatement = function(node) {
    node.body = this.walk(node.body, "body");
    node.test = this.walk(node.test, "test");
    return node;
  };

  ASTWalker.prototype.DebuggerStatement = function(node) {
    return node;
  };

  ASTWalker.prototype.EmptyStatement = function(node) {
    return node;
  };

  ASTWalker.prototype.ExpressionStatement = function(node) {
    node.expression = this.walk(node.expression, "expression");
    return node;
  };

  ASTWalker.prototype.ForStatement = function(node) {
    node.init = this.walk(node.init, "init");
    node.test = this.walk(node.test, "test");
    node.update = this.walk(node.update, "update");
    node.body = this.walk(node.body, "body");
    return node;
  };

  ASTWalker.prototype.ForInStatement = function(node) {
    node.left = this.walk(node.left, "left");
    node.right = this.walk(node.right, "right");
    node.body = this.walk(node.body, "body");
    return node;
  };

  ASTWalker.prototype.FunctionDeclaration = function(node) {
    var el, i, _i, _len, _ref;
    node.id = this.walk(node.id, "id");
    _ref = node.params;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.params[i] = this.walk(el, "params[" + i + "]");
    }
    node.rest = this.walk(node.rest, "rest");
    node.body = this.walk(node.body, "body");
    return node;
  };

  ASTWalker.prototype.FunctionExpression = function(node) {
    var el, i, _i, _len, _ref;
    node.id = this.walk(node.id, "id");
    _ref = node.params;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.params[i] = this.walk(el, "params[" + i + "]");
    }
    node.rest = this.walk(node.rest, "rest");
    node.body = this.walk(node.body, "body");
    return node;
  };

  ASTWalker.prototype.Identifier = function(node) {
    return node;
  };

  ASTWalker.prototype.IfStatement = function(node) {
    node.test = this.walk(node.test, "test");
    node.consequent = this.walk(node.consequent, "consequent");
    node.alternate = this.walk(node.alternate, "alternate");
    return node;
  };

  ASTWalker.prototype.Literal = function(node) {
    return node;
  };

  ASTWalker.prototype.LabeledStatement = function(node) {
    node.label = this.walk(node.label, "label");
    node.body = this.walk(node.body, "body");
    return node;
  };

  ASTWalker.prototype.LogicalExpression = function(node) {
    node.left = this.walk(node.left, "left");
    node.right = this.walk(node.right, "right");
    return node;
  };

  ASTWalker.prototype.MemberExpression = function(node) {
    node.object = this.walk(node.object, "object");
    node.property = this.walk(node.property, "property");
    return node;
  };

  ASTWalker.prototype.NewExpression = function(node) {
    var el, i, _i, _len, _ref;
    node.callee = this.walk(node.callee, "callee");
    _ref = node["arguments"];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node["arguments"][i] = this.walk(el, "arguments[" + i + "]");
    }
    return node;
  };

  ASTWalker.prototype.ObjectExpression = function(node) {
    var el, i, _i, _len, _ref;
    _ref = node.properties;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.properties[i] = this.walk(el, "properties[" + i + "]");
    }
    return node;
  };

  ASTWalker.prototype.Program = function(node) {
    var el, i, _i, _len, _ref;
    _ref = node.body;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.body[i] = this.walk(el, "body[" + i + "]");
    }
    return node;
  };

  ASTWalker.prototype.Property = function(node) {
    node.key = this.walk(node.key, "key");
    node.value = this.walk(node.value, "value");
    return node;
  };

  ASTWalker.prototype.ReturnStatement = function(node) {
    node.argument = this.walk(node.argument, "argument");
    return node;
  };

  ASTWalker.prototype.SequenceExpression = function(node) {
    var el, i, _i, _len, _ref;
    _ref = node.expressions;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.expressions[i] = this.walk(el, "expressions[" + i + "]");
    }
    return node;
  };

  ASTWalker.prototype.SwitchStatement = function(node) {
    var el, i, _i, _len, _ref;
    node.discriminant = this.walk(node.discriminant, "discriminant");
    _ref = node.cases;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.cases[i] = this.walk(el, "cases[" + i + "]");
    }
    return node;
  };

  ASTWalker.prototype.SwitchCase = function(node) {
    var el, i, _i, _len, _ref;
    node.test = this.walk(node.test, "test");
    _ref = node.consequent;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.consequent[i] = this.walk(el, "consequent[" + i + "]");
    }
    return node;
  };

  ASTWalker.prototype.ThisExpression = function(node) {
    return node;
  };

  ASTWalker.prototype.ThrowStatement = function(node) {
    node.argument = this.walk(node.argument, "argument");
    return node;
  };

  ASTWalker.prototype.TryStatement = function(node) {
    var el, i, _i, _len, _ref;
    node.block = this.walk(node.block, "block");
    _ref = node.handlers;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.handlers[i] = this.walk(el, "handlers[" + i + "]");
    }
    node.finalizer = this.walk(node.finalizer, "finalizer");
    return node;
  };

  ASTWalker.prototype.UnaryExpression = function(node) {
    node.argument = this.walk(node.argument, "argument");
    return node;
  };

  ASTWalker.prototype.UpdateExpression = function(node) {
    node.argument = this.walk(node.argument, "argument");
    return node;
  };

  ASTWalker.prototype.VariableDeclaration = function(node) {
    var el, i, _i, _len, _ref;
    _ref = node.declarations;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      el = _ref[i];
      node.declarations[i] = this.walk(el, "declarations[" + i + "]");
    }
    return node;
  };

  ASTWalker.prototype.VariableDeclarator = function(node) {
    node.id = this.walk(node.id, "id");
    node.init = this.walk(node.init, "init");
    return node;
  };

  ASTWalker.prototype.WhileStatement = function(node) {
    node.test = this.walk(node.test, "test");
    node.body = this.walk(node.body, "body");
    return node;
  };

  ASTWalker.prototype.WithStatement = function(node) {
    node.object = this.walk(node.object, "object");
    node.body = this.walk(node.body, "body");
    return node;
  };

  return ASTWalker;

})();

exports.ASTWalker = ASTWalker;

exports.Syntax = Syntax;
